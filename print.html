<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stargate</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02-vocable.html"><strong aria-hidden="true">2.</strong> Vocabulaire</a></li><li class="chapter-item expanded "><a href="03-setup.html"><strong aria-hidden="true">3.</strong> Installations et environnements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-setup-01-centos.html"><strong aria-hidden="true">3.1.</strong> Installation VPS CentOS</a></li><li class="chapter-item expanded "><a href="03-setup-02-dev.html"><strong aria-hidden="true">3.2.</strong> Installation dev</a></li><li class="chapter-item expanded "><a href="03-setup-03-devops.html"><strong aria-hidden="true">3.3.</strong> Environnement DevSecOps</a></li></ol></li><li class="chapter-item expanded "><a href="04-upgrade.html"><strong aria-hidden="true">4.</strong> Mises à niveau</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-upgrade-01-centos.html"><strong aria-hidden="true">4.1.</strong> Mise à niveau sur un VPS CentOS</a></li><li class="chapter-item expanded "><a href="04-upgrade-02-dev.html"><strong aria-hidden="true">4.2.</strong> Mise à niveau environnement local dev</a></li><li class="chapter-item expanded "><a href="04-upgrade-03-devops.html"><strong aria-hidden="true">4.3.</strong> Mise à niveau environnement DevSecOps</a></li></ol></li><li class="chapter-item expanded "><a href="05-architecture.html"><strong aria-hidden="true">5.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-architecture-technologies.html"><strong aria-hidden="true">5.1.</strong> Technologies</a></li><li class="chapter-item expanded "><a href="05-architecture-flux.html"><strong aria-hidden="true">5.2.</strong> Matrice de flux</a></li><li class="chapter-item expanded "><a href="05-architecture-mindef-connect.html"><strong aria-hidden="true">5.3.</strong> Mindef connect</a></li></ol></li><li class="chapter-item expanded "><a href="06-backups.html"><strong aria-hidden="true">6.</strong> Backups</a></li><li class="chapter-item expanded "><a href="07-monitoring.html"><strong aria-hidden="true">7.</strong> Monitoring</a></li><li class="chapter-item expanded "><a href="08-releases.html"><strong aria-hidden="true">8.</strong> Procédure de publication de versions</a></li><li class="chapter-item expanded "><a href="09-common-errors.html"><strong aria-hidden="true">9.</strong> Procédures de corrections fréquentes</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Stargate</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Cette documentation technique a pour objectif de fournir les clefs pour la mise en place d'un environnement fonctionnel Stargate en expliquant le fonctionnement interne ainsi que les différentes interactions entre les briques techniques du projet.</p>
<p>Retrouvez cette documentation sur https://fabnum-minarm.gitlab.io/stargate/docs/</p>
<h2 id="contexte"><a class="header" href="#contexte">Contexte</a></h2>
<p>L'objectif de ce projet est de gérer dynamiquement (avec importation/exportation automatiques de données) des demandes d'accès pour un lieu à responsabilités multiples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexique"><a class="header" href="#lexique">Lexique</a></h1>
<p>Le code du projet étant par convention en anglais et cherchant à être relativement générique (pour être utilisé par d'autres organismes), un lexique est nécessaire.</p>
<table><thead><tr><th>Terme code</th><th>Terme projet</th><th>Description</th></tr></thead><tbody>
<tr><td>Campus</td><td>Base de défense</td><td>Il s'agit du plus grand niveau d'organisation et de groupement du projet. Il sert à séparer et segmenter d'une manière totalement isolée plusieurs lieux ayant à gérer des accès (exemple : deux écoles, ou ici deux bases de défense).</td></tr>
<tr><td>Place</td><td>Lieu</td><td>Il s'agit du plus petit niveau de groupement géographique. Il s'agit d'un lieu tel qu'un bâtiment auquel un visiteur peut demander à accéder.</td></tr>
<tr><td>Zone</td><td>Zone</td><td>Il s'agit d'un groupement de lieux, pour faciliter leur découpage logique et leur recherche.</td></tr>
<tr><td>User</td><td>Utilisateur</td><td>Il s'agit d'un utilisateur ayant accès au projet d'une manière ou d'une autre.</td></tr>
<tr><td>Unit</td><td>Unité</td><td>Il s'agit d'une entité ayant le contrôle de plusieurs lieux (zones).</td></tr>
<tr><td>Request</td><td>Demande</td><td>Il s'agit d’une demande d’accès en tant que telle.</td></tr>
<tr><td>Internal</td><td>MINARM/Hors MINARM</td><td>Il s'agit d'identifier si une demande est faite pour un personnel minarm ou non. Afin de rester générique le terme 'interne' a été retenu pour la notion d'interne entre le demandeur et l'environnement accueillant le visiteur.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installations-et-environnements"><a class="header" href="#installations-et-environnements">Installations et environnements</a></h1>
<p>Dans ce chapitre, vous retrouverez différentes configurations possibles :</p>
<ol>
<li><a href="03-setup-01-centos.html">L'installation sur un VPS CentOS</a></li>
<li><a href="03-setup-02-dev.html">L'installation locale pour du développement</a></li>
<li><a href="03-setup-03-devops.html">Des informations sur la configuration de l'environnement de CI/CD</a></li>
</ol>
<p>Gardez en tête les versions recommandées pour les différentes dépendances : </p>
<ul>
<li>MongoDB &gt;= 3.8</li>
<li>NodeJS LTS 14</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-sur-vps-centos"><a class="header" href="#installation-sur-vps-centos">Installation sur VPS CentOS</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Cette documentation cible l'installation sur un VPS avec CentOS 7, avec un minimum d'interactions sur internet, afin de servir de base pour une installation dans un environnement hors réseau.</p>
<p>Dans le présent document, vous trouverez certaines variables, qui sont utilisées comme en <code>bash</code> dont voici les références : </p>
<table><thead><tr><th>Nom de la variable</th><th>Description</th></tr></thead><tbody>
<tr><td>VERSION</td><td>Version à installer, format vMAJEUR.MINEUR.PATCH</td></tr>
<tr><td>IP_VPS</td><td>L'ip du serveur VPS cible</td></tr>
<tr><td>PATH_ARCHIVE</td><td>Contient le nom du dossier (ou le path absolu) vers le dossier où on va décompresser les fichiers du livrable</td></tr>
<tr><td>BACKEND_DOMAIN</td><td>Le nom de domaine dns du backend</td></tr>
<tr><td>FRONTEND_DOMAIN</td><td>Le nom de domaine dns du frontend</td></tr>
</tbody></table>
<h2 id="téléchargement"><a class="header" href="#téléchargement">Téléchargement</a></h2>
<p>Stargate étant opensource, le téléchargement se fait via la liste des releases sur internet.
Rendez-vous sur <a href="https://gitlab.com/fabnum-minarm/stargate/docs/-/releases">la page des releases du dépôt de documentation</a>, pour chaque version, il y a une liste de packages, avec une archive <code>.tar.bz2</code>.</p>
<p>Utilisez <code>scp</code> pour envoyer l'archive sur le VPS.
Décompressez l'archive grâce à la commande suivante : </p>
<pre><code class="language-bash">mkdir $PATH_ARCHIVE &amp;&amp; tar -C $PATH_ARCHIVE -xjf stargate_${VERSION}.tar.bz2 &amp;&amp; cd $PATH_ARCHIVE
</code></pre>
<h2 id="installation-des-prérequis"><a class="header" href="#installation-des-prérequis">Installation des prérequis</a></h2>
<p>Pour s'exécuter correctement, babel (utilisé dans le backend) a besoin du fichier <code>libc.musl-x86_64.so.1</code>.
Pour l'ajouter, vous trouverez deux packages musl-libc à installer, il faudra ensuite faire un lien symbolique, le tout via les commandes suivantes : </p>
<pre><code class="language-bash">rpm -i ${PATH_ARCHIVE}/binaries/musl-filesystem-*.rpm
rpm -i ${PATH_ARCHIVE}/binaries/musl-libc-*.rpm
ln -s /usr/lib64/libc.so.6 /usr/lib64/libc.musl-x86_64.so.1
</code></pre>
<p>Le package <code>policycoreutils-python</code> sera requis si les commandes <code>checkmodule</code> et <code>semodule_package</code> ne sont pas disponibles.
Le package <code>bzip2</code> sera requis pour décompresser les archives .tar.bz2</p>
<h2 id="installation-de-mongodb"><a class="header" href="#installation-de-mongodb">Installation de MongoDB</a></h2>
<p>Dans le dossier de binaires se trouve un fichier .rpm (for RPM Package Manager) compatible avec CentOS.
Pour l'installer, rien de plus simple :</p>
<pre><code class="language-bash">rpm -i ${PATH_ARCHIVE}/binaries/mongodb-org-server-*.rpm
</code></pre>
<p>Une fois installé, assurez vous que le service sera actif au démarrage avec la commande suivante.</p>
<pre><code class="language-bash">systemctl start mongod # Lance le service
systemctl enable mongod # Lance le service au démarrage
</code></pre>
<h3 id="configurer-selinux-pour-mongodb"><a class="header" href="#configurer-selinux-pour-mongodb">Configurer SELinux pour MongoDB</a></h3>
<p>Une fois installé, il faut créer les règles SELinux suivantes :</p>
<ul>
<li><code>search</code> dans <code>mongod_t</code> &gt; <code>cgroup_t</code> &gt; <code>dir</code></li>
<li><code>getattr</code>, <code>open</code>, <code>read</code> dans <code>mongod_t</code> &gt; <code>cgroup_t</code> &gt; <code>file</code></li>
<li><code>open</code>, <code>read</code> dans <code>mongod_t</code> &gt; <code>proc_net_t</code> &gt; <code>file</code></li>
<li><code>search</code> dans <code>mongod_t</code> &gt; <code>sysctl_net_t</code> &gt; <code>dir</code></li>
</ul>
<p>Ainsi que le fichier <code>mongodb_stargate.te</code> suivant : </p>
<pre><code class="language-selinux">module mongodb_stargate 1.0;

require {
    type cgroup_t;
    type proc_net_t;
    type sysctl_net_t;
    type mongod_t;
    class file { getattr open read };
    class dir search;
}

#============= mongod_t ==============

allow mongod_t cgroup_t:dir search;
allow mongod_t cgroup_t:file { getattr open read };
allow mongod_t proc_net_t:file { open read };
allow mongod_t sysctl_net_t:dir search;
allow mongod_t sysctl_net_t:file { open getattr read };
</code></pre>
<p>Puis lancez les commandes suivantes : </p>
<pre><code class="language-bash">checkmodule -M -m -o mongodb_stargate.mod mongodb_stargate.te
semodule_package -o mongodb_stargate.pp -m mongodb_stargate.mod
semodule -i mongodb_stargate.pp
</code></pre>
<h3 id="désactiver-les-transparent-huge-pages"><a class="header" href="#désactiver-les-transparent-huge-pages">Désactiver les <em>Transparent Huge Pages</em></a></h3>
<p>Pour s'assurer de la configuration à chaque démarrage, créez un service systemd en ajoutant le contenu suivant au fichier <code>/etc/systemd/system/disable-transparent-huge-pages.service</code> :</p>
<pre><code class="language-toml">[Unit]
Description=Disable Transparent Huge Pages (THP)
DefaultDependencies=no
After=sysinit.target local-fs.target
Before=mongod.service
[Service]
Type=oneshot
ExecStart=/bin/sh -c 'echo never | tee /sys/kernel/mm/transparent_hugepage/enabled &gt; /dev/null'
[Install]
WantedBy=basic.target
</code></pre>
<p>Ensuite, lancez les commandes suivantes :</p>
<pre><code class="language-bash">systemctl daemon-reload # Charge le fichier nouvellement créé
systemctl start disable-transparent-huge-pages # Lance le service
systemctl enable disable-transparent-huge-pages # Lance le service au démarrage
</code></pre>
<p>Afin de vérifier la bonne configuration, la commande suivante devrait retourner &quot;never&quot;</p>
<pre><code class="language-bash">cat /sys/kernel/mm/transparent_hugepage/enabled
</code></pre>
<p><em>Sur CentOS 8 uniquement</em>, quelques configurations supplémentaires sont nécessaires pour le virtual-guest.</p>
<p>Créez le répertoire avec la commande suivante : </p>
<pre><code class="language-bash">mkdir -p /etc/tuned/virtual-guest-no-thp
</code></pre>
<p>Ajoutez ensuite le contenu suivant au fichier <code>/etc/tuned/virtual-guest-no-thp/tuned.conf</code> :</p>
<pre><code class="language-toml">[main]
include=virtual-guest
[vm]
transparent_hugepages=never
</code></pre>
<p>Activez enfin le profile tout juste créé avec cette commande : </p>
<pre><code class="language-bash">tuned-adm profile virtual-guest-no-thp
</code></pre>
<h2 id="installation-de-nodejs"><a class="header" href="#installation-de-nodejs">Installation de NodeJS</a></h2>
<p>Pour installer NodeJS depuis l'exécutable présent dans le dossier <code>binaries</code>, utilisez la commande suivante : </p>
<pre><code class="language-bash">export NODE_TAR_NAME=$(basename ${PATH_ARCHIVE}/binaries/node-*.tar.xz .tar.xz)
tar -C /usr/local/bin/ --strip-components=2 -xf ${PATH_ARCHIVE}/binaries/${NODE_TAR_NAME}.tar.xz ${NODE_TAR_NAME}/bin/
tar -C /usr/local/lib/ --strip-components=2 -xf ${PATH_ARCHIVE}/binaries/${NODE_TAR_NAME}.tar.xz ${NODE_TAR_NAME}/lib/
</code></pre>
<p>Pour tester, le plus simple est de vérifier les versions via :</p>
<pre><code class="language-bash">node --version
npm --version
</code></pre>
<h2 id="installation-de-pm2"><a class="header" href="#installation-de-pm2">Installation de PM2</a></h2>
<p>PM2 est un outil de gestion de processus pour NodeJS.</p>
<pre><code class="language-bash">export NODE_LIB_PATH=$(npm list -g --depth=0 | head -1)
tar -C $NODE_LIB_PATH/node_modules -xjf ${PATH_ARCHIVE}/binaries/pm2.tar.bz2 # Décompresse la librairie
ln -s $NODE_LIB_PATH/node_modules/pm2/bin/pm2* /usr/local/bin/ # Créé des liens symboliques vers pm2
</code></pre>
<p>Vérifiez sa bonne installation avec la commande suivante :</p>
<pre><code class="language-bash">pm2 -v
</code></pre>
<h3 id="ajouter-un-service-systemd"><a class="header" href="#ajouter-un-service-systemd">Ajouter un service systemd</a></h3>
<p>Pour assurer le lancement au démarrage, nous allons là encore créer un service systemd, mais cette fois pm2 va être en mesure de le faire directement via la commande suivante : </p>
<pre><code class="language-bash">pm2 startup # Va créer le fichier /etc/systemd/system/pm2-root.service
</code></pre>
<h3 id="configurer-selinux-pour-pm2"><a class="header" href="#configurer-selinux-pour-pm2">Configurer SELinux pour PM2</a></h3>
<p>Pour faire communiquer correctement, il faut ajouter la règle suivante : </p>
<ul>
<li><code>open</code>,<code>read</code>,<code>unlink</code>,<code>write</code> dans <code>init_t</code> &gt; <code>admin_home_t</code> &gt; <code>file</code></li>
</ul>
<p>Pour cela, créez un fichier <code>pm2_systemd.te</code> avec le contenu suivant :</p>
<pre><code class="language-selinux">module pm2_systemd 1.0;

require {
    type admin_home_t;
    type init_t;
    class file { open read unlink write };
}

#============= init_t ==============
allow init_t admin_home_t:file { open read unlink write };
</code></pre>
<p>Il est alors possible d'ajouter la règle via les commandes suivantes : </p>
<pre><code class="language-bash">checkmodule -M -m -o pm2_systemd.mod pm2_systemd.te
semodule_package -o pm2_systemd.pp -m pm2_systemd.mod
semodule -i pm2_systemd.pp
</code></pre>
<h2 id="installer-le-code-de-stargate"><a class="header" href="#installer-le-code-de-stargate">Installer le code de Stargate</a></h2>
<p>Nous allons utiliser le dossier <code>/opt/stargate</code> pour placer le backend et le frontend du projet.
Créons le dossier d'abord via <code>mkdir</code> :</p>
<pre><code class="language-bash">mkdir -p /opt/stargate
</code></pre>
<h3 id="installer-le-backend"><a class="header" href="#installer-le-backend">Installer le backend</a></h3>
<p>Pour installer le backend, nous allons : </p>
<ul>
<li>Déplacer le backend dans son répertoire</li>
<li>Nous placer dans ce répertoire</li>
<li>Lancer un rebuild des modules <code>npm</code> pour s'assurer qu'ils soient compatibles avec le système linux et la version de node.</li>
<li>Exécuter <code>npm run migrations:up --if-present</code> afin d'exécuter d'éventuelles migrations automatiques</li>
<li>Ajouter dans pm2</li>
</ul>
<pre><code class="language-bash">mv ${PATH_ARCHIVE}/stargate_backend /opt/stargate/backend
cd /opt/stargate/backend
npm rebuild
HOST=127.0.0.1 PROMETHEUS_EXPORTER=0 pm2 start npm --name 'backend' -- start
</code></pre>
<h4 id="personnaliser-la-configuration"><a class="header" href="#personnaliser-la-configuration">Personnaliser la configuration</a></h4>
<p>La configuration se fait via des variables d'environnement. Il suffit de les exporter dans le shell courant, avant de mettre à jour les variables prises en compte par <code>pm2</code>.</p>
<p>Il est ensuite possible ensuite de lister les variables d'environnement prises en compte avec <code>pm2 env</code></p>
<pre><code class="language-bash">export MONGODB=mongodb://localhost:27017/stargate
export MAIL__DEFAULT_FROM= # Expéditeur des emails
export MAIL__TRANSPORTER__HOST= # Nom de domaine du serveur mail
export MAIL__TRANSPORTER__PORT= # Port du serveur mail
export MAIL__TRANSPORTER__AUTH__PASS= # Mot de passe pour l'authentification mail
export MAIL__TRANSPORTER__AUTH__USER= # Utilisateur pour l'authentification mail
export TOKEN__SECRET=$(tr -dc 'A-Za-z0-9!&quot;#$%&amp;'\''()*+,-./:;&lt;=&gt;?@[\]^_`{|}~' &lt;/dev/urandom | head -c 128 ) # Va être utilisé comme preuve cryptographique pour les jetons JWT
export WEBSITE_URL=https://${FRONTEND_DOMAIN}
pm2 restart backend --update-env
pm2 env $(pm2 ls | grep backend | awk -F'│' '{print $2}') # Vérifier
</code></pre>
<h3 id="installer-le-frontend"><a class="header" href="#installer-le-frontend">Installer le frontend</a></h3>
<p>Pour installer le frontend, nous allons :</p>
<ul>
<li>Déplacer le frontend dans son répertoire</li>
<li>Nous placer dans ce répertoire</li>
<li>Lancer un rebuild des modules <code>npm</code> pour s'assurer qu'ils soient compatibles avec le système linux et la version de node.</li>
<li>Ajouter dans pm2</li>
</ul>
<pre><code class="language-bash">mv ${PATH_ARCHIVE}/stargate_frontend /opt/stargate/frontend
cd /opt/stargate/frontend
npm rebuild
PORT=3001 HOST=127.0.0.1 PROMETHEUS_HOST=127.0.0.1 pm2 start npm --name 'frontend' -- start -- --host 127.0.0.1
</code></pre>
<h4 id="mettre-à-jour-lapi-url"><a class="header" href="#mettre-à-jour-lapi-url">Mettre à jour l'API URL</a></h4>
<p>La configuration se fait via des variables d'environnement. Il suffit de les exporter dans le shell courant, avant de mettre à jour les variables prises en compte par <code>pm2</code>.</p>
<p>Il est ensuite possible ensuite de lister les variables d'environnement prises en compte avec <code>pm2 env</code></p>
<pre><code class="language-bash">export API_URL=https://${BACKEND_DOMAIN}/api
pm2 restart frontend --update-env
pm2 env $(pm2 ls | grep frontend | awk -F'│' '{print $2}') # Vérifier
</code></pre>
<h2 id="nginx"><a class="header" href="#nginx">Nginx</a></h2>
<p>Installons nginx avec <code>rpm -i ${PATH_ARCHIVE}/binaries/nginx-*.rpm</code>.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Éditons le fichier <code>/etc/nginx/nginx.conf</code> comme suit :</p>
<pre><code class="language-nginx"># For more information on configuration, see:
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>
<p>Pour la configuration du backend, éditons le fichier <code>/etc/nginx/conf.d/backend.conf</code><br />
Attention, modifiez bien le $BACKEND_DOMAIN dans le fichier avec le nom de domaine du frontend</p>
<pre><code class="language-nginx">server {
  listen 80;
  server_name $BACKEND_DOMAIN;
  location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Host $host;
    proxy_set_header X-NginX-Proxy true;

    proxy_pass http://localhost:3000;
    proxy_redirect http://localhost:3000/ http://$server_name/;
  }
}
</code></pre>
<p>Pour la configuration du frontend, éditons le fichier <code>/etc/nginx/conf.d/frontend.conf</code><br />
Attention, modifiez bien le $FRONTEND_DOMAIN dans le fichier avec le nom de domaine du frontend</p>
<pre><code class="language-nginx">server {
  listen 80;
  server_name $FRONTEND_DOMAIN;
  location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Host $host;
    proxy_set_header X-NginX-Proxy true;

    proxy_pass http://localhost:3001;
    proxy_redirect http://localhost:3001/ http://$server_name/;
  }
}
</code></pre>
<h3 id="configurons-selinux"><a class="header" href="#configurons-selinux">Configurons SELinux</a></h3>
<p>Pour nginx, le plus simple est de configurer SELinux via la commande <code>setsebool -P httpd_can_network_connect on</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-sur-poste-de-développement"><a class="header" href="#installation-sur-poste-de-développement">Installation sur poste de développement</a></h1>
<p>Cette procédure d'installation vaut pour un environnement local dans lequel aucune résilience n’est requise.
Il est réputé acquis que toutes les données peuvent être perdues.</p>
<h2 id="prérequis"><a class="header" href="#prérequis">Prérequis</a></h2>
<p>Tout d'abord, il faudra installer quelques prérequis :</p>
<ul>
<li>Linux ou Windows avec sous système linux. Il est théoriquement possible de faire tourner le projet sur Windows mais le présent document ne traite pas ce cas.</li>
<li>Git</li>
<li>libc, gcc pour la compilation de certaines dépendances</li>
</ul>
<h3 id="nodejs"><a class="header" href="#nodejs">NodeJS</a></h3>
<p>Si NodeJS n'est pas déjà installé, nous recommandons l'utilisation de <a href="https://github.com/Schniz/fnm">fnm</a> via la procédure manuelle.
Notez qu'il est préférable, dans un environnement sécurisé, de ne pas utiliser de script bash directement exécuté depuis internet.
Une fois installé, vous pourrez exécuter les commandes suivantes :</p>
<pre><code class="language-bash">fnm install 14 # Installe la version 14, actuelle LTS
fnm use 14 # Utilise la version 14, actuelle LTS dans l'environnement courant
fnm default 14 # Mets la version 14 par défaut (optionnel) 
</code></pre>
<h3 id="mongodb"><a class="header" href="#mongodb">MongoDB</a></h3>
<p>Si MongoDB n'est pas installé, vous pouvez l'installer ou bien le lancer via Docker.</p>
<h4 id="installation-locale"><a class="header" href="#installation-locale">Installation locale</a></h4>
<p>Nous utilisons MongoDB Community Edition, vous trouverez les procédures d'installation sur <a href="https://docs.mongodb.com/manual/installation/">le site officiel</a>.</p>
<h4 id="installation-via-docker"><a class="header" href="#installation-via-docker">Installation via Docker</a></h4>
<p>Si Docker est installé au préalable, vous pouvez utiliser directement les commandes suivantes :</p>
<pre><code class="language-bash">mkdir -p ./mongodb/data/db # Créer un répertoire pour persister la base de données.
docker run --name stargate_mongo -p 27017:27017 -v `pwd`/mongodb/data/db:/data/db -d mongo:5.0 # Créé et lance un conteneur
</code></pre>
<h2 id="web-api-backend"><a class="header" href="#web-api-backend">Web API (Backend)</a></h2>
<p>Pour installer ce projet, il faut :</p>
<ul>
<li>Cloner le projet <a href="https://gitlab.com/fabnum-minarm/stargate/backend">backend</a></li>
<li>Mettre à niveau les dépendances via <code>npm install</code></li>
<li>Build si nécessaire via <code>npm run build --if-present</code></li>
<li>Lancer les migrations si nécessaire via <code>npm run migrations:up --if-present</code></li>
<li>Lancer l'application via la commande <code>npm run dev</code></li>
</ul>
<h2 id="web-app-frontend"><a class="header" href="#web-app-frontend">Web App (Frontend)</a></h2>
<p>Pour installer ce projet, il faut :</p>
<ul>
<li>Cloner le projet <a href="https://gitlab.com/fabnum-minarm/stargate/frontend">frontend</a></li>
<li>Mettre à niveau les dépendances via <code>npm install</code></li>
<li>Build si nécessaire via <code>npm run build --if-present</code></li>
<li>Lancer l'application via la commande <code>npm run dev</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environnement-cicd-gitlab"><a class="header" href="#environnement-cicd-gitlab">Environnement CI/CD gitlab</a></h1>
<p>L'environnement CI/CD est simplifié par <a href="https://igloo.fabnum.fr">Igloo</a>.
Le runner qui traite les tâches est également hébergé dans les clusters <a href="https://igloo.fabnum.fr">Igloo</a>.</p>
<h2 id="clusters"><a class="header" href="#clusters">Clusters</a></h2>
<p>Deux clusters Igloo existent, un pour la production et un pour le développement. Ils sont traités différemment :</p>
<ul>
<li>Les données du cluster de développement sont réputées volatiles.</li>
<li>Le cluster de développement héberge également les runners de CI.</li>
</ul>
<h2 id="workflows"><a class="header" href="#workflows">Workflows</a></h2>
<p>Dans les grandes lignes, nous suivons le <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">gitlab flow</a> :</p>
<ul>
<li>À la création d'une nouvelle branche, un environnement non dédié est créé.<br />
Non dédié signifie que l'espace de nom Kubernetes, dans lequel est hébergé la solution, est partagé avec les autres environnements stargate créés au même moment. L’espace mémoire et CPU réservé sont partagés entre tous les environnements dits de review. La base de données est également partagée.</li>
<li>Au merge sur develop, un environnement est dédié est créé.</li>
<li>Au tag, un environnement dédié est créé sur l'environnement de production.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mises-à-niveau"><a class="header" href="#mises-à-niveau">Mises à niveau</a></h1>
<p>Dans ce chapitre, vous retrouverez les procédures de mise à niveau pour les différentes configurations possibles :</p>
<ol>
<li><a href="04-upgrade-01-centos.html">Mise à niveau sur un VPS CentOS</a></li>
<li><a href="04-upgrade-02-dev.html">Mise à niveau locale pour du développement</a></li>
<li><a href="04-upgrade-03-devops.html">Des informations sur la mise à niveau automatique de l'environnement de CI/CD</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-à-niveau-sur-un-vps-centos"><a class="header" href="#mise-à-niveau-sur-un-vps-centos">Mise à niveau sur un VPS CentOS</a></h1>
<p>Cette documentation cible la mise à niveau sur un VPS avec CentOS 8.</p>
<p>Dans le présent document, vous trouverez certaines variables, qui sont utilisées comme en <code>bash</code> dont voici les références :</p>
<table><thead><tr><th>Nom de la variable</th><th>Description</th></tr></thead><tbody>
<tr><td>VERSION</td><td>Version à installer, format vMAJEUR.MINEUR.PATCH</td></tr>
<tr><td>IP_VPS</td><td>L'ip du serveur VPS cible</td></tr>
<tr><td>PATH_ARCHIVE</td><td>Contient le nom du dossier (ou le path absolu) vers le dossier où on va décompresser les fichiers du livrable</td></tr>
<tr><td>BACKEND_DOMAIN</td><td>Le nom de domaine dns du backend</td></tr>
<tr><td>FRONTEND_DOMAIN</td><td>Le nom de domaine dns du frontend</td></tr>
</tbody></table>
<h2 id="téléchargement-1"><a class="header" href="#téléchargement-1">Téléchargement</a></h2>
<p>Stargate étant opensource, le téléchargement se fait via la liste des releases sur internet.
Rendez-vous sur <a href="https://gitlab.com/fabnum-minarm/stargate/docs/-/releases">la page des releases du dépôt de documentation</a>, pour chaque version, il y a une liste de packages, avec une archive <code>.tar.bz2</code>.</p>
<p>Utilisez <code>scp</code> pour envoyer l'archive sur le VPS.
Décompressez l'archive grâce à la commande <code>mkdir $PATH_ARCHIVE &amp;&amp; tar -C $PATH_ARCHIVE -xjf stargate_${VERSION}.tar.bz2 &amp;&amp; cd $PATH_ARCHIVE</code></p>
<h3 id="mettre-à-niveau-le-backend"><a class="header" href="#mettre-à-niveau-le-backend">Mettre à niveau le backend</a></h3>
<p>Pour installer le backend, nous allons :</p>
<ul>
<li>Déplacer le backend dans son répertoire</li>
<li>Nous placer dans ce répertoire</li>
<li>Lancer un rebuild des modules <code>npm</code> pour s'assurer qu'ils soient compatibles avec le système linux et la version de node.</li>
<li>Exécuter <code>npm run migrations:up --if-present</code> afin d'exécuter d'éventuelles migrations automatiques</li>
<li>Relancer dans pm2</li>
</ul>
<pre><code class="language-bash">rsync -a --remove-source-files ${PATH_ARCHIVE}/stargate_backend /opt/stargate/backend
cd /opt/stargate/backend
npm rebuild
npm run migrations:up --if-present
pm2 restart backend
</code></pre>
<h3 id="mettre-à-niveau-le-frontend"><a class="header" href="#mettre-à-niveau-le-frontend">Mettre à niveau le frontend</a></h3>
<p>Pour installer le frontend, nous allons :</p>
<ul>
<li>Déplacer le frontend dans son répertoire</li>
<li>Nous placer dans ce répertoire</li>
<li>Lancer un rebuild des modules <code>npm</code> pour s'assurer qu'ils soient compatibles avec le système linux et la version de node.</li>
<li>Relancer dans pm2</li>
</ul>
<pre><code class="language-bash">rsync -a --remove-source-files ${PATH_ARCHIVE}/stargate_frontend /opt/stargate/frontend
cd /opt/stargate/frontend
npm rebuild
pm2 restart frontend
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-à-niveau-environnement-local-dev"><a class="header" href="#mise-à-niveau-environnement-local-dev">Mise à niveau environnement local dev</a></h1>
<p>Afin de mettre à niveau l'environnement local, il suffit de récupérer la nouvelle version de code et d’exécuter les éventuelles migrations de données.</p>
<h2 id="backend--frontend"><a class="header" href="#backend--frontend">Backend &amp; Frontend</a></h2>
<p>Pour mettre à niveau chaque projet, il faut :</p>
<ul>
<li>Mettre à jour le code via <code>git pull</code></li>
<li>Mettre à niveau les dépendances via <code>npm install</code></li>
<li>Build si nécessaire via <code>npm run build --if-present</code></li>
<li>Lancer les migrations si nécessaire via <code>npm run migrations:up --if-present</code></li>
<li>Relancer l'application</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mise-à-niveau-environnement-devsecops"><a class="header" href="#mise-à-niveau-environnement-devsecops">Mise à niveau environnement DevSecOps</a></h1>
<p>L'environnement Igloo tire avantage des <code>hooks</code> <a href="https://helm.sh">helm</a> afin d'avoir des actions déclanchées automatiquement suivant le cycle de vie de l'application. Rien n'est à prévoir.</p>
<ul>
<li>Au <code>pre-upgrade</code> et <code>pre-install</code>, le script <code>npm run migrations:up --if-present</code> est exécuté</li>
<li>Au <code>post-install</code>, le script <code>npm run fixtures:load --if-present</code> est exécuté</li>
<li>Au <code>post-delete</code>, la base de données est supprimée</li>
</ul>
<h2 id="astuces"><a class="header" href="#astuces">Astuces</a></h2>
<p>Pour forcer le système à recréer les fixtures, il suffit de stop l'environnement puis le recréer. Toutes les données seront perdues</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<ul>
<li><a href="05-architecture-technologies.html">Technologies utilisées</a></li>
<li><a href="05-architecture-flux.html">Matrices de flux</a></li>
<li><a href="05-architecture-mindef-connect.html">Informations mindef connect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technologies"><a class="header" href="#technologies">Technologies</a></h1>
<p>La motivation dans le choix des technologies pour ce projet fut d’une part, de choisir des technologies fiables, limitant le périmètre de connaissances techniques et la courbe d'apprentissage pour le personnel non familier (permettant de faciliter les recrutements).</p>
<p>D'autre part, certaines technologies ont été sélectionnées afin de bénéficier de leur scalabilité permettant de donner à la solution une haute disponibilité si désirée.</p>
<h2 id="backend"><a class="header" href="#backend">Backend</a></h2>
<h3 id="web-api"><a class="header" href="#web-api">Web API</a></h3>
<p>La web API est écrite en Javascript et fonctionne sur NodeJS &gt;= 12.</p>
<ul>
<li>babel-node sert à convertir le code ES6 vers ES5, nodeJS est en mesure de le faire à partir de la version 12, cependant babel est utilisé pour permettre une utilisation sans douleur des modules ES6 dans NodeJS. Cette dépendance pourrait être retirée quand NodeJS supportera mieux les modules ES6.</li>
<li>Pino sert à générer les logs.</li>
<li>Koa permet de décrire le routing de l'API, décrire le comportement CORS ou encore parser le contenu JSON entrant.</li>
<li>Apollo est utilisé en tant que serveur graphQL.</li>
<li>ESLint garantit le format de code.</li>
<li>Jest est utilisé afin de lancer les tests unitaires.</li>
<li>Mongoose est utilisé comme ORM pour faciliter l'exploitation de la base de données.</li>
</ul>
<h3 id="base-de-données"><a class="header" href="#base-de-données">Base de données</a></h3>
<p>Le système de base de données utilisé est MongoDB. 
Il s'agit d'une base de données no-SQL, dite schemaless, c'est-à-dire qu'elle ne requiert pas la définition d'un schéma en amont. Notre utilisation de MongoDB reste basique : écriture / lecture / agrégation.</p>
<p>Notre utilisation de MongoDB reste basique : écriture / lecture / aggrégation.</p>
<h2 id="frontend"><a class="header" href="#frontend">Frontend</a></h2>
<h3 id="reactjs--nextjs"><a class="header" href="#reactjs--nextjs">ReactJS &amp; NextJS</a></h3>
<p>NextJS est utilisé pour permettre un rendu serveur du code (SSR).</p>
<h2 id="intégration--système"><a class="header" href="#intégration--système">Intégration &amp; système</a></h2>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Docker est utilisé afin de construire des conteneurs Linux pouvant être exécutés localement, en préproduction et en production. Il est utilisé pour garantir l'idempotence de déploiement entre deux conteneurs linux.</p>
<h3 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h3>
<p>Kubernetes est utilisé pour les besoins du développement, en créant un environnement dédié à chaque branche créée pour faciliter les tests et les recettes.</p>
<h3 id="gitlab-ci"><a class="header" href="#gitlab-ci">Gitlab CI</a></h3>
<p>Gitlab est utilisé pour son système d'intégration continue / déploiement continue afin de vérifier le code, lancer les tests unitaires, construire et héberger les images docker ainsi qu’orchestrer les déploiements automatiques sur Kubernetes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrices-de-flux"><a class="header" href="#matrices-de-flux">Matrices de flux</a></h1>
<p>La matrice de flux est très dépendante de comment est installé l'application.</p>
<h2 id="installation-avec-conteneurisation"><a class="header" href="#installation-avec-conteneurisation">Installation avec conteneurisation</a></h2>
<table><thead><tr><th>Source</th><th>Destination</th><th>Port(s)</th><th>Protocole</th><th>Description</th></tr></thead><tbody>
<tr><td>Client</td><td>Proxy</td><td>80/443*</td><td>HTTP/HTTPS*</td><td>Accès web utilisateur</td></tr>
<tr><td>Backend</td><td>Serveur SMTP</td><td>587 (ou autre port SMTP)</td><td>SMTP</td><td>Envoie des notifications mail</td></tr>
<tr><td>Backend</td><td>MongoDB</td><td>27017</td><td>TCP</td><td>Connexion DB</td></tr>
<tr><td>Proxy</td><td>Backend</td><td>3000</td><td>HTTP</td><td>Le backend est accessible via le proxy</td></tr>
<tr><td>Proxy</td><td>Frontend</td><td>3000</td><td>HTTP</td><td>Le frontend est accessible via le proxy</td></tr>
<tr><td>Frontend</td><td>Backend</td><td>3000</td><td>HTTP</td><td>Le frontend interroge le backend pour le rendu côté serveur</td></tr>
</tbody></table>
<p>Complément d'informations : Le projet remonte logs et metrics</p>
<table><thead><tr><th>Source</th><th>Destination</th><th>Port(s)</th><th>Protocole</th><th>Description</th></tr></thead><tbody>
<tr><td>Administrateur</td><td>Proxy</td><td>443</td><td>HTTP/HTTPS</td><td>Accès web</td></tr>
<tr><td>Proxy</td><td>Grafana</td><td>80</td><td>HTTP</td><td>Le monitoring est accessible via le proxy</td></tr>
<tr><td>Grafana</td><td>Prometheus</td><td>9090</td><td>HTTP</td><td>Requête les métriques</td></tr>
<tr><td>Prometheus</td><td>InfluxDB</td><td>8086</td><td>HTTP</td><td>TimeSeries database</td></tr>
<tr><td>Prometheus</td><td>Backend</td><td>9091</td><td>HTTP</td><td>Scrape métriques</td></tr>
<tr><td>Prometheus</td><td>Frontend</td><td>9091</td><td>HTTP</td><td>Scrape métriques</td></tr>
</tbody></table>
<h2 id="installation-classique"><a class="header" href="#installation-classique">Installation classique</a></h2>
<table><thead><tr><th>Source</th><th>Destination</th><th>Port(s)</th><th>Protocole</th><th>Description</th></tr></thead><tbody>
<tr><td>Client</td><td>Nginx</td><td>80/443*</td><td>HTTP/HTTPS*</td><td>Accès web utilisateur</td></tr>
<tr><td>Client</td><td>SSH</td><td>22</td><td>SSH</td><td>Accès administration SSH</td></tr>
<tr><td>Backend</td><td>Serveur SMTP</td><td>587 (ou autre port SMTP)</td><td>SMTP</td><td>Envoie des notifications mail</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intégration-mindef-connect"><a class="header" href="#intégration-mindef-connect">Intégration mindef connect</a></h1>
<p>Attention : La documentation ici présente est le fruit de rétro-ingénierie, en l'absence de documentation officielle en accès libre.</p>
<h2 id="implémentation"><a class="header" href="#implémentation">Implémentation</a></h2>
<p>L'implémentation sur stargate du protocole openid est partielle, on se contente de récupérer un jeton, d'introspecter deans pour récupérer l'email, afin de générer un jeton JWT stargate</p>
<p><img src="./images/mindef-connect.png" alt="Interactions mindef connect" /></p>
<h2 id="configuration-keycloak"><a class="header" href="#configuration-keycloak">Configuration Keycloak</a></h2>
<p>Pour pouvoir utiliser keycloak pour tester l'implémentation, il faut :</p>
<ol>
<li>Créer un <em>realm</em></li>
<li>Créer un <em>client</em>
<ol>
<li>Passer ce <em>client</em> en type &quot;confidentiel&quot;</li>
<li>Définir des Redirect URI autorisées</li>
</ol>
</li>
<li>Créer un <em>utilisateur</em>
<ol>
<li>Définir un mot de passe sur cet <em>utilisateur</em></li>
</ol>
</li>
<li>Configurer les variables du backend avec :
<ol>
<li>L'URL du <em>realm</em></li>
<li>L'ID du <em>client</em></li>
<li>Le secret du <em>client</em></li>
</ol>
</li>
</ol>
<p>Plus de détails sur la méthode de configuration dans <a href="https://fabnum-minarm.gitlab.io/igloo/docs/third-party/mindef-connect.html">la documentation Igloo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backups"><a class="header" href="#backups">Backups</a></h1>
<p>L'application Stargate sauvegarde la totalité des données dans MongoDB. Ainsi, il s'agit du seul point à sauvegarder.</p>
<h2 id="base-de-données-1"><a class="header" href="#base-de-données-1">Base de données</a></h2>
<p>Il est <em>possible</em> sur mongodb de faire une sauvegarde directe des fichiers de la base de données ou de les snapshot via le système de fichier afin de faire des sauvegardes incrémentales.</p>
<p>Autrement, utilisez les outils CLI dédiés comme <code>mongodump</code>.</p>
<p>Vous pouvez alors copier le dossier de base de données. Pour trouver ce dossier, regardez la clef <code>storage.dbPath</code> dans <code>/etc/mongod.conf</code>.
Par défaut <code>/var/lib/mongo</code>.</p>
<h3 id="test-de-cohérence-et-de-réintégration-après-un-backup-du-système-de-fichier"><a class="header" href="#test-de-cohérence-et-de-réintégration-après-un-backup-du-système-de-fichier">Test de cohérence et de réintégration après un backup du système de fichier</a></h3>
<p>Via docker installé, le plus simple est de créer des conteneurs à la volée pour faire un repair et lancer <code>mongod</code> dans la foulée.
Ici, $PATH_TO_BACKUP correspond au répertoire où la base de données a été téléchargée.</p>
<pre><code class="language-bash">docker run --rm -it -v $PATH_TO_BACKUP:/data/db mongo:latest mongod --repair
docker run --rm -it -p 27017:27017 -v $PATH_TO_BACKUP:/data/db mongo:latest mongod
</code></pre>
<p>Pour pousser le test, il suffit de comparer le nombre de documents dans chaque collection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h1>
<h2 id="sondes"><a class="header" href="#sondes">Sondes</a></h2>
<p>Afin de savoir si les services sont up, il est possible de :</p>
<ul>
<li>Interroger <code>pm2</code></li>
<li>Appeler en HTTP la racine des applications</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procédure-de-publication-de-versions"><a class="header" href="#procédure-de-publication-de-versions">Procédure de publication de versions</a></h1>
<h2 id="numéros-de-versions"><a class="header" href="#numéros-de-versions">Numéros de versions</a></h2>
<p>Le projet utilise une <a href="https://semver.org/lang/fr/spec/v2.0.0.html">gestion sémantique de version</a>.</p>
<p>Ce qu'il faut retenir :</p>
<ul>
<li>Les versions comprennent trois parties <em>MAJEUR</em>.<em>MINEUR</em>.<em>CORRECTIF</em></li>
<li>Quand un incrément du <em>CORRECTIF</em> est fait, il suffit de mettre à jour les sources et relancer le logiciel</li>
<li>Quand un incrément du <em>MINEUR</em> est fait, il suffit de mettre à jour les sources, lancer le script de migration, et relancer le logiciel</li>
<li>Quand un incrément du <em>MAJEUR</em> est fait, il y aura une attention particulière à apporter à la procédure de migration, des changements manuels seront probables, une incompatibilité de données pouvant exister</li>
</ul>
<h2 id="procédure-de-création-de-version"><a class="header" href="#procédure-de-création-de-version">Procédure de création de version</a></h2>
<p>Trois dépôts existent : le backend, le frontend, et le meta-dépôt. Pour créer une version il suffit de :</p>
<ol>
<li>Créer un tag avec <code>npm version</code> sur le backend</li>
<li>Créer un tag avec <code>npm version</code> sur le frontend</li>
<li>Créer un tag avec de la forme <code>vMAJEUR.MINEUR.CORRECTIF</code> via <code>git</code> ou l'interface gitlab sur le meta-dépôt, uniquement quand les releases backend et frontend auront été créées via leurs CI respectives</li>
<li>Le meta-dépôt ira chercher les versions du même numéro sur le backend et frontend, il est important qu'elles soient identiques.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procédures-de-corrections-derreurs-fréquentes"><a class="header" href="#procédures-de-corrections-derreurs-fréquentes">Procédures de corrections d'erreurs fréquentes</a></h1>
<h2 id="mongodb-1"><a class="header" href="#mongodb-1">MongoDB</a></h2>
<h3 id="la-base-de-données-ne-se-lance-plus"><a class="header" href="#la-base-de-données-ne-se-lance-plus">La Base de données ne se lance plus</a></h3>
<p>Après un arrêt secteur inopiné du VPS, il peut y avoir une désynchronisation qui empêche WiredTiger de récupérer correctement les données et mongodb de se lancer.</p>
<p>Attention : N'hésitez pas à copier la base de données via rsync ou dd afin d'avoir une copie des fichiers corrompus en cas d'échec de la réparation.</p>
<p>Pour résoudre ça :</p>
<pre><code class="language-bash">systemctl stop mongodb
mongod -f /etc/mongod.conf --repair
systemctl start mongodb
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
